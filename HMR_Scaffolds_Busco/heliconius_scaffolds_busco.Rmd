---
title: "Identifying H. m. rosina Scaffolds Using Hmel2.5"
author: "Krista Pipho"
date: "`r Sys.Date()`"
output: html_document
bibliography: scaffolds.bib
link-citations: true
---

```{r file_info, include=FALSE}
"
To re-run this analysis with a different assembly: 1. Replace data in the 'Tables' block with appropriate output from QUAST and BUSCO and 2. Place BUSCO output with top two header lines removed in the same folder as this RMD. 

"
```

```{r Packages, message=FALSE}
library(tidyverse)
library(kableExtra) # Formatting Tables
library(pheatmap) # Plotting Heatmap 
library(jsonlite) # Querying Orthodb 
```

![Heliconius melpomene rosina](HMR.jpg){width=250px}  


### Introduction  

In November of 2023 the Wray Lab sent a Heliconius melpomene rosina pupal sample to the Duke genomics core facility for Pacbio HIFI sequencing. The resulting reads were fed into the HIFIasm software [@Cheng2021] to create a de novo assembled reference genome(below left)[@Gurevich2013]. The new genome's completeness was preliminary assessed by using BUSCO docker [@Busco2015] to search for a set of conserved lepadopteran genes in the published H. melpomene 2.5 genome [@Davey2016] as well as our new assembly. The resulting H. m. rosina BUSCO values are very high, and slightly better than those for Hmel2.5 (below right). Here we use the conserved genes found by BUSCO to identify the relationship between scaffolds in Hmel2.5 and H. m. rosina. In this analysis scaffolds containing many of the same BUSCO annotations are presumed to be homologous chromosomes. 


```{r Tables, echo=FALSE}
quast_table <- tribble(
   ~`QUAST Statistics`, ~`Scaffolds`, ~`L50`, ~`L90`,
   "Hmel2.5", 332, 9, 19,
   "H. m. rosina", 120, 9, 20,
)

busco_table <- tribble(
   ~`% of 5286 Conserved Genes`, ~`Complete`, ~`Duplicated `, ~`Missing`,
   "Hmel2.5", 98.7, 0.40, 1.0,
   "H. m. rosina", 98.9, 0.30, 0.9,
)

quast_table %>%
  kable("html", align = 'clc') %>%
    kable_styling(full_width = F, position = "float_left")
 
busco_table %>%
  kable("html", align = 'clc') %>%
    kable_styling(full_width = F, position = "right")
```
  
  
### Scaffold Overview

```{r}
hmr_scaffolds <- read.csv("hmr.p_ctg.fa.fai",sep="\t", header=FALSE, skip = 2) %>% select(V1, V2)
hed_scaffolds <- read.csv("hed.p_ctg.fa.fai",sep="\t", header=FALSE, skip = 2) %>% select(V1, V2)
hmel2.5_scaffolds <- read.csv("Heliconius_melpomene_melpomene_Hmel2.5.scaffolds.fa.fai",sep="\t", header=FALSE, skip = 2) %>% select(V1, V2)


hmr_scaffolds$assembly <- "hmr"
hmel2.5_scaffolds$assembly <- "hmel2.5"
combined_scaffold_table <- rbind(hmr_scaffolds,hmel2.5_scaffolds)
```

```{r, fig.height=4, fig.width=8}
ggplot(combined_scaffold_table, aes(x = V2, fill=assembly)) +
 geom_histogram( color="#e9ecef", alpha=0.6, bins = 50) +
    scale_fill_manual(values=c("#69b3a2", "#404080")) +
    scale_x_log10() +
  scale_y_log10() +
    theme_bw() +
  ylab("Count") +
  xlab("Scaffold Size")+
  theme(text=element_text(size=21))
```


```{r}
ggplot(hed_scaffolds, aes(x = V2)) +
  geom_histogram() +
    scale_x_log10() +
  scale_y_log10()
```


```{r}
ggplot(hmel2.5_scaffolds, aes(x = V2)) +
  geom_histogram() +
    scale_x_log10() +
  scale_y_log10() +
    theme_bw() +
  ylab("Count") +
  xlab("Hmel2.5 Scaffold Sizes") 
```

  
### BUSCO Overview

Here I load data generated by BUSCO, which contains BUSCO IDs of conserved genes along with scaffold and base pair locations of the gene in the assembly. See below a summary visual of BUSCO gene number per scaffold. Empty category names correspond to BUSCO genes not found anywhere in the assemblies. 
  
  


```{r BUSCO Data, figures-side, fig.show="hold", out.width="50%"}
#These tables must have the headers fixed with underscores

### Open Hmel2.5 BUSCO results
melpomene_busco <- read.csv("hmel2.5_full_table.tsv",sep="\t", header=TRUE, skip = 2)

# Group results by scaffold name, and count genes per scaffold
# Empty row name corresponds to BUSCO genes that were not found in the assembly
melpomene_busco_table <- melpomene_busco %>%
 group_by(Sequence) %>% summarise(n = n()) %>% arrange(n) %>% as_tibble()

# Plot number of BUSCO genes per scaffold
ggplot(melpomene_busco_table, aes(x=reorder(Sequence, -n), y=n)) +
  geom_bar(stat = "identity") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) + 
  xlab("Hmel2.5 Scaffold Name") +
  ylab("Number of BUSCO Genes") 

### Open hmr BUSCO results
our_busco <- read.csv("hmr_full_table.tsv",sep="\t", header=TRUE, skip = 2)

# Group results by scaffold name, and count genes per scaffold
# Empty row name corresponds to BUSCO genes that were not found in the assembly
our_busco_table <- our_busco %>%
 group_by(Sequence) %>% summarise(n = n()) %>% arrange(n) %>% as_tibble()

# Plot number of BUSCO genes per scaffold
ggplot(our_busco_table, aes(x=reorder(Sequence, -n), y=n)) +
  geom_bar(stat = "identity") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))+ 
  xlab("HMR Scaffold Name") +
  ylab("Number of BUSCO Genes") 

``` 




Next I extract lists of BUSCO genes present on each scaffold, then make every possible pairwise overlap comparison between Hmel2.5 and Hmr scaffolds. Overlaps of at least one gene but fewer than 8 genes represent small deviations between assemblies, including some genes that are moved, duplicated, or found in only one assembly. These are stored for further analysis. Overlaps of 8 or more genes are used to assign homology between scaffolds in the two assemblies. A list of homologous assemblies is printed below, accompanied by a heatmap visual of gene overlap. 

```{r Gene Overlap Matrix, fig.height=8, fig.width=8}

# Extract the BUSCO gene names per scaffold (Hmel2.5)
melpomene_busco$Sequence <- factor(melpomene_busco$Sequence) 
melpomene_busco2 <-melpomene_busco %>%
 group_by(melpomene_busco$Sequence) %>% summarize(TheList = list(Busco_id)) %>% select(TheList)

melpomeneList <- melpomene_busco2[[1]]
names(melpomeneList) <- levels(melpomene_busco$Sequence)


# Extract the BUSCO gene names per scaffold (Hmr)
our_busco$Sequence <- factor(our_busco$Sequence) 
our_busco2 <-our_busco %>%
 group_by(our_busco$Sequence) %>% summarize(TheList = list(Busco_id)) %>% select(TheList)

rosinaList <- our_busco2[[1]]
names(rosinaList) <- levels(our_busco$Sequence)

# Build an empty matrix to hold all pairwise overlap comparisons
x  <- matrix(NA_real_, length(melpomeneList), length(rosinaList))
rownames(x) <- names(melpomeneList) 
colnames(x) <- names(rosinaList)

found.or.moved.genes <- c() # Makes list of genes present in small overlaps

# Loop through all pairs of hmel2.5 x hmr scaffolds and quantify busco gene overlap
for (i in seq_along(melpomeneList)){
  for (j in seq_along(rosinaList)){ 
    
      # Creates a list of overlapped genes
      gene.list <- intersect(unlist(melpomeneList[i]), unlist(rosinaList[j]))
      
      # Creates a list of genes that represent small, unexpected overlaps (genes only in one assembly or assembled onto different scaffolds)
      if (length(gene.list) > 0 && length(gene.list) < 8) { found.or.moved.genes <- c(found.or.moved.genes,gene.list)
      #cat(names(rosinaList[j]), "\t", names(melpomeneList[i]), "\t", length(gene.list), "\n")
      }
      
      # Creates and print out a list of scaffold pairs with 8 or more BUSCO gene overlaps
      if (length(gene.list) > 7) {cat(names(rosinaList[j]), "\t", names(melpomeneList[i]), "\t", length(gene.list), "\n")
        }
      x[i,j] <- length(gene.list)
    }
}

# Creates a modified overlap matrix and plots the result
x_adj = x
x_adj[x_adj == 0] <- -20 #  Changed to better visualize small non-zero overlap numbers
pheatmap::pheatmap(x_adj,cluster_rows = FALSE)
```


```{r}
### Open hed BUSCO results
hed_busco <- read.csv("hed_full_table.tsv",sep="\t", header=TRUE, skip = 2)

# Group results by scaffold name, and count genes per scaffold
# Empty row name corresponds to BUSCO genes that were not found in the assembly
hed_busco_table <- hed_busco %>%
 group_by(Sequence) %>% summarise(n = n()) %>% arrange(n) %>% as_tibble()

# Plot number of BUSCO genes per scaffold
ggplot(hed_busco_table, aes(x=reorder(Sequence, -n), y=n)) +
  geom_bar(stat = "identity") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))+ 
  xlab("HED Scaffold Name") +
  ylab("Number of BUSCO Genes") 


# Extract the BUSCO gene names per scaffold (Hmr)
hed_busco$Sequence <- factor(hed_busco$Sequence) 
hed_busco2 <-hed_busco %>%
 group_by(hed_busco$Sequence) %>% summarize(TheList = list(Busco_id)) %>% select(TheList)

rosinaList <- hed_busco2[[1]]
names(rosinaList) <- levels(hed_busco$Sequence)

# Build an empty matrix to hold all pairwise overlap comparisons
x  <- matrix(NA_real_, length(melpomeneList), length(rosinaList))
rownames(x) <- names(melpomeneList) 
colnames(x) <- names(rosinaList)

found.or.moved.genes <- c() # Makes list of genes present in small overlaps

# Loop through all pairs of hmel2.5 x hmr scaffolds and quantify busco gene overlap
for (i in seq_along(melpomeneList)){
  for (j in seq_along(rosinaList)){ 
    
      # Creates a list of overlapped genes
      gene.list <- intersect(unlist(melpomeneList[i]), unlist(rosinaList[j]))
      
      # Creates a list of genes that represent small, unexpected overlaps (genes only in one assembly or assembled onto different scaffolds)
      if (length(gene.list) > 0 && length(gene.list) < 8) { found.or.moved.genes <- c(found.or.moved.genes,gene.list)
      #cat(names(rosinaList[j]), "\t", names(melpomeneList[i]), "\t", length(gene.list), "\n")
      }
      
      # Creates and print out a list of scaffold pairs with 8 or more BUSCO gene overlaps
      if (length(gene.list) > 7) {cat(names(rosinaList[j]), "\t", names(melpomeneList[i]), "\t", length(gene.list), "\n")
        }
      x[i,j] <- length(gene.list)
    }
}

# Creates a modified overlap matrix and plots the result
x_adj = x
x_adj[x_adj == 0] <- -20 #  Changed to better visualize small non-zero overlap numbers
pheatmap::pheatmap(x_adj,cluster_rows = FALSE)
```
```


### Utilities for Further Analysis 

The code below is intended for modification and use in further analysis. The portions of it that deal with retrieving information about BUSCO genes from OrthoDB [@Kriventseva2019] are inspired by and modified from the following links:

https://www.ezlab.org/orthodb_userguide.html#api  
https://gitlab.com/ezlab/busco/-/issues/347  
https://v10-1.orthodb.org/?page=api  

```{r}
found.or.moved.genes
```

```{r Utilities}

# Example print command to get BUSCO IDs for any scaffold
print(melpomeneList[7])
print(rosinaList)

busco_ids <- found.or.moved.genes
names(busco_ids) <- busco_ids # fix for map_df .id issue

# a tibble of profiles associated with each busco_id
busco_ipr <- map_df(busco_ids, .id="busco_id",  function(busco_id){
  
  # map the BUSCO ID to OrthoDB group ID
  query <- read_json(paste0("http://v101.orthodb.org/search?query=", busco_id))
  odb_id <- query$data[1]
  
  # get all info on the orthogroup via quiery 
  odb_info <- read_json(paste0("http://v101.orthodb.org/group?id=", odb_id),
  simplifyVector = TRUE)
  
  # return the info table
  odb_info$data$interpro_domains
})

busco_ipr %>% select(busco_id, description) %>% tibble() 
```

## References
<div id="refs"></div>
  
.    

```{r Session Information}
sessionInfo()
```
